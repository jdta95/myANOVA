`Sum Sq` = SSs,
`Mean Sq` = MSSs,
`F value` = Fs,
`Pr(>F)` = ps)
model_names = names(mod$model)
attributes(ret)$row.names = c(model_names[2:(par + 1)],
"Residuals")
attributes(ret)$class = c("anova", "data.frame")
attributes(ret)$heading = c("Analysis of Variance Table\n",
paste0("Response: ", model_names[1], collapse = ""))
return(ret)
}
my_anova_intercept = function(mod) {
n = nrow(mod$model)
df = n - 1
SS = sum((mod$model[, 1] - mod$coefficients) ^ 2)
MSS = SS / df
ret = list(Df = df,
`Sum Sq` = SS,
`Mean Sq` = MSS,
`F value` = NA * 0,
`Pr(>F)` = NA * 0)
attributes(ret)$row.names = "Residuals"
attributes(ret)$class = c("anova", "data.frame")
attributes(ret)$heading = c("Analysis of Variance Table\n",
paste0("Response: ", names(mod$model), collapse = ""))
return(ret)
}
get_dfs = function(col) {
if (class(col) == "factor" | class(col) == "character") {
df = length(unique(col)) - 1
}
else {
df = 1
}
return(df)
}
my_anova2 = function(mods) {
len = length(mods)
res_dfs = sapply(mods, function(mod) mod$df.residual)
RSSs = sapply(mods, function(mod) sum(mod$residuals ^ 2))
dfs = integer(len)
dfs[1] = NA
dfs[2:len] = res_dfs[1:(len - 1)] - res_dfs[2:len]
SSs = numeric(len)
SSs[1] = NA
SSs[2:len] = RSSs[1:(len - 1)] - RSSs[2:len]
Fs = numeric(len)
Fs[1] = NA
Fs[2:len] = ((RSSs[1:(len - 1)] - RSSs[2:len]) / dfs[2:len]) /
(RSSs[len] / res_dfs[len])
ps = pf(Fs, dfs, res_dfs[len], lower.tail = FALSE)
ret = list(Res.Df = res_dfs,
RSS = RSSs,
Df = dfs,
`Sum of Sq` = SSs,
`F` = Fs,
`Pr(>F)` = ps)
attributes(ret)$class = c("anova", "data.frame")
attributes(ret)$row.names = as.character(1:len)
formula_strs = sapply(mods, function(mod) as.character(mod$call)[2])
attributes(ret)$heading = c("Analysis of Variance Table\n",
paste0("Model ",
1:len,
": ",
formula_strs,
collapse = "\n"))
return(ret)
}
my_anova = function(...) {
mods = list(...)
if (any(sapply(mods, function(mod) class(mod) != "lm"))) {
stop("At least one of the objects supplied to my_anova does not have class \"lm\".")
}
if (length(mods) > 1) {
return(my_anova2(mods))
}
else if (ncol(mods[[1]]$model) == 1) {
return(my_anova_intercept(mods[[1]]))
}
else {
return(my_anova1(mods[[1]]))
}
}
data(mtcars)
mod1 = lm(mpg ~ cyl, data = mtcars)
mod2 = lm(mpg ~ cyl + disp, data = mtcars)
my_anova(mod2)
my_anova(mod1, mod2)
out = anova(mod2)
my_out = my_anova(mod2)
all.equal(out, my_out)
out = anova(mod1, mod2)
my_out = my_anova(mod1, mod2)
all.equal(out, my_out)
?all.equal
?lm
roxygen2::roxygenise()
?roxygen2::roxygenise
rm(get_dfs)
rm(my_anova)
rm(my_anova_intercept())
rm(my_anova_intercept)
rm(my_anova1)
rm(my_anova2)
devtools::install_github("jdta95/myANOVA")
devtools::install_github("jdta95/myANOVA")
data(mtcars)
mod1 = lm(mpg ~ cyl, data = mtcars)
mod2 = lm(mpg ~ cyl + disp, data = mtcars)
myANOVA::my_anova(mod1, mod2)
my_out = myANOVA::my_anova(mod1, mod2)
out = anova(mod1, mod2)
all.equal(my_out, out)
?myANOVA::my_anova
?anova
?devtools::build_vignettes
?usethis::use_vignette
usethis::use_vignette(myanova_vignette)
usethis::use_vignette("myanova_vignette")
library(myANOVA)
# Load a dataset
data(mtcars)
View(mtcars)
# Create a linear model
mod = lm(mpg ~ cyl + disp + hp, data = mtcars)
my_anova(mod)
anova(mod)
?mtcars
typeof(mtcars$gear)
typeof(mtcars$carb)
# Load a dataset
data(iris)
View(iris)
colnames(iris)
blah = lm(Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width + Species, data=iris)
summary(blah)
# Create a linear model
mod = lm(Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width + Species,
data = iris)
my_anova(mod)
unique(iris$Species)
n = nrow(mod$model)
par = ncol(mod$model) - 1
Ybar = mean(mod$model[, 1])
dfs = unname(c(sapply(mod$model[, -1, drop = FALSE], get_dfs), mod$df.residual))
SSs = numeric(par + 1)
mod$model[, 2]
my_anova(mod)
data(iris)
mod1 = lm(Sepal.Length ~ Sepal.Width,
data = iris)
mod2 = lm(Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width,
data = iris)
mod3 = lm(Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width + Species,
data = iris)
my_anova(mod1, mod2, mod3)
my_anova(mod2, mod3)
mod2 = lm(Sepal.Length ~ Sepal.Width+ Petal.Length + Petal.Width,
data = iris)
my_anova(mod1, mod2)
mod2 = lm(Sepal.Length ~ 1+Sepal.Width+ Petal.Length + Petal.Width,
data = iris)
my_anova(mod1, mod2)
anova(mod1, mod2)
my_anova(mod1, mod2)
anova(mod1, mod2)
blah = lm(Sepal.Length ~ Species, data = iris)
blah2 = lm(Sepal.Length ~ Species + Sepal.Width, data = iris)
blah = lm(Sepal.Length ~ -1 + Species, data = iris)
blah2 = lm(Sepal.Length ~ -1 Species + Sepal.Width, data = iris)
blah2 = lm(Sepal.Length ~ -1 + Species + Sepal.Width, data = iris)
out = anova(blah, blah2)
my_out = my_anova(blah, blah2)
out
my_out
all.equal(out, my_out)
my_anova(mod1, mod2)
# Load the dataset
data(iris)
# Create nested linear models
mod1 = lm(Sepal.Length ~ Sepal.Width,
data = iris)
mod2 = lm(Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width,
data = iris)
my_anova(mod1, mod2)
mod3 = lm(Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width + Species,
data = iris)
my_anova(mod1, mod2, mod3)
my_anova(mod1, mod2)
my_anova(mod1, mod2, mod3)
?devtools::build_vignettes
devtools::build_vignettes()
devtools::uninstall("myANOVA")
devtools::install_github("jdta95/myANOVA", build_vignettes = TRUE)
browseVignettes("myANOVA")
?usethis::use_testthat
usethis::use_testthat()
usethis::use_test("my_anova")
?test_that
data(iris)
colnames(iris)
?lm
devtools::test()
out = anova(mod1b)
mod1b = lm(Sepal.Length ~ -1 + Species,
data = iris)
data(iris)
mod1b = lm(Sepal.Length ~ -1 + Species,
data = iris)
out = anova(mod1b)
out
mod1 = lm(Sepal.Length ~ Species,
data = iris)
anova(mod1)
mod1 = lm(Sepal.Length ~ Species + Sepal.Width,
data = iris)
mod1b = lm(Sepal.Length ~ -1 + Species + Sepal.Width,
data = iris)
out = anova(mod1b)
out
my_anova_cellmeans = function(mod) {
n = nrow(mod$model)
par = ncol(mod$model) - 1
Ybar = mean(mod$model[, 1])
dfs = unname(c(sapply(mod$model[, -1, drop = FALSE], get_dfs), mod$df.residual))
index = min(which(sapply(mod$model[, -1, drop = FALSE],
function(col) {
class(col) == "factor" | class(col) == "character"
})))
dfs[index] = dfs[index] + 1
SSs = numeric(par + 1)
SSs[1] = sum((lm(mod$model[, 1] ~ mod$model[, 2])$fitted.values - Ybar) ^ 2) - sum(SSs)
if (par > 1) {
for (i in 2:par) {
pars = 2:i
formula_str = paste0("mod$model[, 1] ~ ",
paste0("mod$model[, ", 2:(i + 1), collapse = "] + "),
"]")
SSs[i] = sum((lm(as.formula(formula_str))$fitted.values - Ybar) ^ 2) - sum(SSs)
}
SSs[i + 1] = sum((mod$model[, 1] - mod$fitted.values) ^ 2)
}
else {
SSs[2] = sum((mod$model[, 1] - mod$fitted.values) ^ 2)
}
MSSs = SSs / dfs
Fs = c(MSSs[-length(MSSs)] / MSSs[length(MSSs)], NA)
ps = pf(Fs, dfs[-length(dfs)], dfs[length(dfs)], lower.tail = FALSE)
ret = list(Df = dfs,
`Sum Sq` = SSs,
`Mean Sq` = MSSs,
`F value` = Fs,
`Pr(>F)` = ps)
model_names = names(mod$model)
attributes(ret)$row.names = c(model_names[2:(par + 1)],
"Residuals")
attributes(ret)$class = c("anova", "data.frame")
attributes(ret)$heading = c("Analysis of Variance Table\n",
paste0("Response: ", model_names[1], collapse = ""))
return(ret)
}
mod1b = lm(Sepal.Length ~ -1 + Species + Sepal.Width,
data = iris)
mod1b
my_anova(mod1b)
my_anova_cellmeans(mod1b)
anova(mod1b)
rm(my_anova_cellmeans())
rm(my_anova_cellmeans)
out
my_anova1_cellmeans = function(mod) {
n = nrow(mod$model)
par = ncol(mod$model) - 1
Ybar = mean(mod$model[, 1])
dfs = unname(c(sapply(mod$model[, -1, drop = FALSE], get_dfs), mod$df.residual))
index = min(which(sapply(mod$model[, -1, drop = FALSE],
function(col) {
class(col) == "factor" | class(col) == "character"
})))
dfs[index] = dfs[index] + 1
SSs = numeric(par + 1)
SSs[1] = sum((lm(mod$model[, 1] ~ -1 + mod$model[, 2])$fitted.values - Ybar) ^ 2) - sum(SSs)
if (par > 1) {
for (i in 2:par) {
pars = 2:i
formula_str = paste0("mod$model[, 1] ~ -1 + ",
paste0("mod$model[, ", 2:(i + 1), collapse = "] + "),
"]")
SSs[i] = sum((lm(as.formula(formula_str))$fitted.values - Ybar) ^ 2) - sum(SSs)
}
SSs[i + 1] = sum((mod$model[, 1] - mod$fitted.values) ^ 2)
}
else {
SSs[2] = sum((mod$model[, 1] - mod$fitted.values) ^ 2)
}
MSSs = SSs / dfs
Fs = c(MSSs[-length(MSSs)] / MSSs[length(MSSs)], NA)
ps = pf(Fs, dfs[-length(dfs)], dfs[length(dfs)], lower.tail = FALSE)
ret = list(Df = dfs,
`Sum Sq` = SSs,
`Mean Sq` = MSSs,
`F value` = Fs,
`Pr(>F)` = ps)
model_names = names(mod$model)
attributes(ret)$row.names = c(model_names[2:(par + 1)],
"Residuals")
attributes(ret)$class = c("anova", "data.frame")
attributes(ret)$heading = c("Analysis of Variance Table\n",
paste0("Response: ", model_names[1], collapse = ""))
return(ret)
}
my_anova_cellmeans(mod1b)
my_anova1_cellmeans(mod1b)
out
my_anova1_cellmeans = function(mod) {
n = nrow(mod$model)
par = ncol(mod$model) - 1
Ybar = mean(mod$model[, 1])
dfs = unname(c(sapply(mod$model[, -1, drop = FALSE], get_dfs), mod$df.residual))
index = min(which(sapply(mod$model[, -1, drop = FALSE],
function(col) {
class(col) == "factor" | class(col) == "character"
})))
dfs[index] = dfs[index] + 1
SSs = numeric(par + 1)
SSs[1] = sum((lm(mod$model[, 1] ~ -1 + mod$model[, 2])$fitted.values - Ybar) ^ 2) - sum(SSs)
if (par > 1) {
for (i in 2:par) {
pars = 2:i
formula_str = paste0("mod$model[, 1] ~ -1 + ",
paste0("mod$model[, ", 2:(i + 1), collapse = "] + "),
"]")
SSs[i] = sum((lm(as.formula(formula_str))$fitted.values - Ybar) ^ 2) - sum(SSs)
}
SSs[i + 1] = sum((mod$model[, 1] - mod$fitted.values) ^ 2)
}
else {
SSs[2] = sum((mod$model[, 1] - mod$fitted.values) ^ 2)
}
MSSs = SSs / dfs
Fs = c(MSSs[-length(MSSs)] / MSSs[length(MSSs)], NA)
ps = pf(Fs, dfs[-length(dfs)], dfs[length(dfs)], lower.tail = FALSE)
ret = list(Df = dfs,
`Sum Sq` = SSs,
`Mean Sq` = MSSs,
`F value` = Fs,
`Pr(>F)` = ps)
model_names = names(mod$model)
attributes(ret)$row.names = c(model_names[2:(par + 1)],
"Residuals")
attributes(ret)$class = c("anova", "data.frame")
attributes(ret)$heading = c("Analysis of Variance Table\n",
paste0("Response: ", model_names[1], collapse = ""))
return(ret)
}
my_anova1_cellmeans(mod1b)
mod = mod1b
n = nrow(mod$model)
par = ncol(mod$model) - 1
Ybar = mean(mod$model[, 1])
dfs = unname(c(sapply(mod$model[, -1, drop = FALSE], get_dfs), mod$df.residual))
index = min(which(sapply(mod$model[, -1, drop = FALSE],
function(col) {
class(col) == "factor" | class(col) == "character"
})))
dfs[index] = dfs[index] + 1
dfs
out
SSs = numeric(par + 1)
SSs[1] = sum((lm(mod$model[, 1] ~ -1 + mod$model[, 2])$fitted.values - Ybar) ^ 2) - sum(SSs)
if (par > 1) {
for (i in 2:par) {
pars = 2:i
formula_str = paste0("mod$model[, 1] ~ -1 + ",
paste0("mod$model[, ", 2:(i + 1), collapse = "] + "),
"]")
SSs[i] = sum((lm(as.formula(formula_str))$fitted.values - Ybar) ^ 2) - sum(SSs)
}
SSs[i + 1] = sum((mod$model[, 1] - mod$fitted.values) ^ 2)
}
SSs = numeric(par + 1)
SSs[1] = sum((lm(mod$model[, 1] ~ -1 + mod$model[, 2])$fitted.values - Ybar) ^ 2) - sum(SSs)
if (par > 1) {
for (i in 2:par) {
pars = 2:i
formula_str = paste0("mod$model[, 1] ~ -1 + ",
paste0("mod$model[, ", 2:(i + 1), collapse = "] + "),
"]")
SSs[i] = sum((lm(as.formula(formula_str))$fitted.values - Ybar) ^ 2) - sum(SSs)
}
SSs[i + 1] = sum((mod$model[, 1] - mod$fitted.values) ^ 2)
}
else {
SSs
anova(mod)
blah = lm(mod$model[, 1] ~ -1 + mod$model[, 2])
blah = lm(Sepal.Length ~ -1 + Species + Sepal.Width, data = iris)
sum((blah$fitted.values - mean(iris$Sepal.Length)) ^ 2)
anova(mod1b)
sum((mod1b$fitted.values - mean(iris$Sepal.Length)) ^ 2)
blah = lm(Sepal.Length ~ -1 + Species, data = iris)
sum((blah$fitted.values - mean(iris$Sepal.Length)) ^ 2)
(blah$residuals ^ 2) / (150 - 3)
sum(blah$residuals ^ 2) / (150 - 3)
out
blah = lm(Sepal.Length ~ -1 + Species,
data = iris)
sum(blah$residuals ^ 2) / (150 - 3)
sum(blah$residuals ^ 2) / 3
SSs
sum((blah$fitted.values - Ybar) ^ 2)
blah
summary(blah)
sum_blah = summary(blah)
sum_blah$coefficients
sum_blah$coefficients[1, 2]
sum_blah$coefficients[1, 2] / sqrt(n)
blah
out
SST = sum((iris$Sepal.Length - mean(iris$Sepal.Length)) ^ 2)
SST
blah$coefficients[, 1]
blah$coefficients[1]
blah$coefficients
table(iris$Sepal.Length)
table(iris$Species)
table(iris$Species)[1]
table(iris$Species)[2]
SSM = sum((blah$coefficients - mean(iris$Sepal.Length)) ^ 2 * table(iris$Species))
SSE = SST - SSM
my_anova(mod)
table(iris$Species)
mean(iris$Sepal.Length[iris$Species == "setosa"])
mean(iris$Sepal.Length[iris$Species == "versicolor"])
mean(iris$Sepal.Length[iris$Species == "virginica"])
sum(50 * (blah$coefficients - mean(iris$Sepal.Length)) ^ 2)
anova(lm(Sepal.Length ~ 1, data = iris))
my_anova(lm(Sepal.Length ~ 1, data = iris))
my_anova(lm(Sepal.Length ~ -1 + Species, data = iris))
anova(lm(Sepal.Length ~ -1 + Species, data = iris))
list(blah)
list(blah)$model
list(blah)[[1]]$model
list(blah)[[1]]$call
typeof(list(blah)[[1]]$call)
class(list(blah)[[1]]$call)
grepl("~ -1", (list(blah)[[1]]$call))
any(grepl("~ -1", (list(blah)[[1]]$call)))
any(grepl("~ -1", (list(lm(Sepal.Length ~ 0 + Species, data = iris))[[1]]$call)))
list(lm(Sepal.Length ~ 0 + Species, data = iris))[[1]]$call
list(lm(Sepal.Length ~ Species + 0, data = iris))[[1]]$call
list(lm(Sepal.Length ~ Species +0, data = iris))[[1]]$call
list(lm(Sepal.Length ~ Species-1, data = iris))[[1]]$call
?grepl
list(lm(Sepal.Length ~ Species-0, data = iris))[[1]]$call
list(lm(Sepal.Length ~ Species-0, data = iris))[[1]]
my_anova = function(...) {
mods = list(...)
if (any(sapply(mods, function(mod) class(mod) != "lm"))) {
stop("At least one of the objects supplied to my_anova does not have class \"lm\".")
}
if (length(mods) == 1 & (any(grepl(" - 1", mods[[1]]$call)) | any(grepl(" + 0", mods[[1]]$call))))
stop("An intercept-only linear model cannot be the only object supplied to my_anova.")
if (length(mods) > 1) {
return(my_anova2(mods))
}
else if (ncol(mods[[1]]$model) == 1) {
return(my_anova_intercept(mods[[1]]))
}
else {
return(my_anova1(mods[[1]]))
}
}
?expect_error
unique(iris$Species)
modglm = glm(Species ~ Sepal.Length + Sepal. Width + Petal.Length + Petal Width,
modglm = glm(Species ~ Sepal.Length + Sepal. Width + Petal.Length + Petal.Width,
modglm = glm(Species ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width,
data = iris[iris$Species %in% c("setosa", "versicolor")],
family = "binomial")
modglm = glm(Species ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width,
data = iris[iris$Species %in% c("setosa", "versicolor"), ],
family = "binomial")
modglm = glm(Species ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width,
data = iris[iris$Species %in% c("versicolor", "virginica"), ],
family = "binomial")
modglm
anova(modglm)
View(iris[iris$Species %in%
c("versicolor", "virginica"), ])
devtools::install_github("jdta95/myANOVA")
devtools::test()
devtools::test()
modcm = lm(Sepal.Length ~ -1 + Species,
data = iris)
my_anova(modcm)
mods = list(modcm)
length(mods) == 1 & (any(grepl(" - 1", mods[[1]]$call)) | any(grepl(" + 0", mods[[1]]$call)))
modcm$call
modcm = lm(Sepal.Length ~ - 1 + Species,
data = iris)
modcm$call
devtools::install_github("jdta95/myANOVA")
devtools::test()
usethis::use_github_actions()
?usethis::use_github_action
usethis::use_github_action()
usethis::use_github_action()
devtools::install_github("jdta95/myANOVA")
?myANOVA::my_anova
roxygen2::roxygenise()
